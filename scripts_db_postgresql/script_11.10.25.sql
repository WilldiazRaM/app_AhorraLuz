-- ======================================================================
-- PostgreSQL (DBeaver) – Esquema normalizado 3FN con validaciones mínimas
-- ======================================================================

-- Extensión para UUIDs
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ========================
-- 1) Catálogos básicos
-- ========================
CREATE TABLE cat_tipo_vivienda (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL UNIQUE
);

CREATE TABLE cat_tipo_dispositivo (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL UNIQUE
);

CREATE TABLE cat_nivel_alerta (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo TEXT NOT NULL UNIQUE,      -- LOW/MEDIUM/HIGH
  descripcion TEXT
);

CREATE TABLE cat_tipo_notificacion (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo TEXT NOT NULL UNIQUE,      -- PRED_ALTA/LOGRO/SISTEMA
  descripcion TEXT
);

CREATE TABLE cat_comuna (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL UNIQUE
);

-- ========================
-- 2) Seguridad / Usuarios
-- ========================
CREATE TABLE usuarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  activo BOOLEAN NOT NULL DEFAULT TRUE,
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  actualizado_en TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Identidades de login (email único “case-insensitive”)
CREATE TABLE auth_identidades (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  contrasena_hash TEXT NOT NULL,         -- sin constraints adicionales (a petición)
  ultimo_acceso TIMESTAMPTZ,
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  actualizado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- email formato básico
  CONSTRAINT ck_auth_email_formato
    CHECK (email ~* '^[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$')
);
-- unicidad case-insensitive
CREATE UNIQUE INDEX ux_auth_identidades_email_ci
  ON auth_identidades (lower(email));

-- Perfil del usuario
CREATE TABLE perfiles (
  usuario_id UUID PRIMARY KEY REFERENCES usuarios(id) ON DELETE CASCADE,
  rut TEXT UNIQUE,
  nombres VARCHAR(100),
  apellidos VARCHAR(100),
  tipo_vivienda_id SMALLINT REFERENCES cat_tipo_vivienda(id),
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  actualizado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- Rut chileno (formato simple 7-8 dígitos + guion + dígito o K)
  CONSTRAINT ck_perfiles_rut_formato
    CHECK (rut IS NULL OR rut ~* '^[0-9]{7,8}-[0-9Kk]$')
);

-- Dirección separada (3FN)
CREATE TABLE direcciones (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  calle VARCHAR(120) NOT NULL,
  numero VARCHAR(20),
  depto VARCHAR(20),
  comuna_id INTEGER REFERENCES cat_comuna(id),
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  actualizado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_direccion_calle_no_vacia CHECK (length(trim(calle)) > 0)
);

-- ========================
-- 3) RBAC
-- ========================
CREATE TABLE roles (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL UNIQUE,
  descripcion TEXT
);

CREATE TABLE permisos (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo TEXT NOT NULL UNIQUE,
  descripcion TEXT
);

CREATE TABLE rol_permiso (
  rol_id SMALLINT REFERENCES roles(id) ON DELETE CASCADE,
  permiso_id SMALLINT REFERENCES permisos(id) ON DELETE CASCADE,
  PRIMARY KEY (rol_id, permiso_id)
);

CREATE TABLE usuario_rol (
  usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
  rol_id SMALLINT REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (usuario_id, rol_id)
);

-- ========================
-- 4) Dispositivos y Consumo
-- ========================
CREATE TYPE fuente_lectura AS ENUM ('manual', 'automatica');

CREATE TABLE dispositivos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  nombre VARCHAR(100) NOT NULL,
  tipo_dispositivo_id SMALLINT REFERENCES cat_tipo_dispositivo(id),
  potencia_promedio_w NUMERIC(10,2) DEFAULT 0 CHECK (potencia_promedio_w >= 0),
  horas_uso_diario NUMERIC(5,2) DEFAULT 0 CHECK (horas_uso_diario >= 0 AND horas_uso_diario <= 24),
  activo BOOLEAN NOT NULL DEFAULT TRUE,
  fecha_registro TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_dispositivo_nombre_no_vacio CHECK (length(trim(nombre)) > 0)
);
CREATE INDEX idx_dispositivos_usuario ON dispositivos (usuario_id);

CREATE TABLE registros_consumo (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  fecha DATE NOT NULL,
  consumo_kwh NUMERIC(12,4) NOT NULL CHECK (consumo_kwh >= 0),
  costo_clp NUMERIC(14,2) CHECK (costo_clp IS NULL OR costo_clp >= 0),
  dispositivo_id BIGINT REFERENCES dispositivos(id) ON DELETE SET NULL,
  fuente fuente_lectura NOT NULL DEFAULT 'manual',
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- No permitir fechas futuras para lecturas manuales/automáticas
  CONSTRAINT ck_registro_fecha_pasada CHECK (fecha <= CURRENT_DATE)
);
-- Evitar duplicados por usuario/fecha/dispositivo (considerando NULL)
CREATE UNIQUE INDEX ux_registros_consumo_user_fecha_disp
  ON registros_consumo (usuario_id, fecha, COALESCE(dispositivo_id, -1));

-- ========================
-- 5) Predicciones y Alertas
-- ========================
CREATE TABLE predicciones_consumo (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  fecha_prediccion DATE NOT NULL,
  periodo_inicio DATE NOT NULL,
  periodo_fin DATE NOT NULL,
  consumo_predicho_kwh NUMERIC(12,4) NOT NULL CHECK (consumo_predicho_kwh >= 0),
  nivel_alerta_id SMALLINT REFERENCES cat_nivel_alerta(id),
  creado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_pred_periodo_valido CHECK (periodo_fin >= periodo_inicio)
);
CREATE INDEX idx_predicciones_usuario_periodo
  ON predicciones_consumo (usuario_id, periodo_inicio, periodo_fin);

-- ========================
-- 6) Notificaciones
-- ========================
CREATE TABLE notificaciones (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  tipo_id SMALLINT REFERENCES cat_tipo_notificacion(id),
  titulo VARCHAR(140),
  mensaje TEXT NOT NULL,
  leida BOOLEAN NOT NULL DEFAULT FALSE,
  creada_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_notif_mensaje_no_vacio CHECK (length(trim(mensaje)) > 0)
);
CREATE INDEX idx_notificaciones_usuario_leida ON notificaciones (usuario_id, leida);

-- ========================
-- 7) Métricas mensuales (agregado)
-- ========================
CREATE TABLE metricas_mensuales (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  periodo_mes DATE NOT NULL,  -- usar SIEMPRE el día 1 del mes
  consumo_kwh NUMERIC(14,4) NOT NULL CHECK (consumo_kwh >= 0),
  ahorro_clp NUMERIC(14,2) CHECK (ahorro_clp IS NULL OR ahorro_clp >= 0),
  reduccion_huella_co2_kg NUMERIC(14,3) CHECK (reduccion_huella_co2_kg >= 0),
  comparacion_mes_anterior_pct NUMERIC(6,2),
  calculado_en TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT ck_metricas_mes_primer_dia
    CHECK (date_trunc('month', periodo_mes) = periodo_mes),
  UNIQUE (usuario_id, periodo_mes)
);
CREATE INDEX idx_metricas_usuario_mes ON metricas_mensuales (usuario_id, periodo_mes);

-- ========================
-- 8) Auditoría simple
-- ========================
CREATE TABLE auditoria_eventos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id UUID,
  entidad TEXT NOT NULL,
  entidad_id TEXT,
  accion TEXT NOT NULL,
  detalle JSONB,
  ip TEXT,
  user_agent TEXT,
  ocurrido_en TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ========================
-- 9) Triggers updated_at
-- ========================
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.actualizado_en = now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER tg_usuarios_updated_at
BEFORE UPDATE ON usuarios FOR EACH ROW EXECUTE PROCEDURE set_updated_at();

CREATE TRIGGER tg_auth_identidades_updated_at
BEFORE UPDATE ON auth_identidades FOR EACH ROW EXECUTE PROCEDURE set_updated_at();

CREATE TRIGGER tg_perfiles_updated_at
BEFORE UPDATE ON perfiles FOR EACH ROW EXECUTE PROCEDURE set_updated_at();

CREATE TRIGGER tg_direcciones_updated_at
BEFORE UPDATE ON direcciones FOR EACH ROW EXECUTE PROCEDURE set_updated_at();

-- ========================
-- 10) Seeds mínimos
-- ========================
INSERT INTO roles (nombre, descripcion) VALUES
  ('admin','Administrador del sistema'),
  ('usuario','Usuario final')
ON CONFLICT DO NOTHING;

INSERT INTO cat_nivel_alerta (codigo, descripcion) VALUES
  ('LOW','Bajo'), ('MEDIUM','Medio'), ('HIGH','Alto')
ON CONFLICT DO NOTHING;

INSERT INTO cat_tipo_notificacion (codigo, descripcion) VALUES
  ('PRED_ALTA','Predicción de alto consumo'),
  ('LOGRO','Logro/Sello de ahorro'),
  ('SISTEMA','Mensajes del sistema')
ON CONFLICT DO NOTHING;


ALTER TABLE rol_permiso ADD COLUMN id BIGSERIAL PRIMARY KEY;
ALTER TABLE usuario_rol ADD COLUMN id BIGSERIAL PRIMARY KEY;
-- Ejemplos (opcional)
-- INSERT INTO cat_tipo_vivienda (nombre) VALUES ('Casa'), ('Departamento') ON CONFLICT DO NOTHING;
-- INSERT INTO cat_tipo_dispositivo (nombre) VALUES ('Refrigerador'), ('Lavadora'), ('Aire Acondicionado') ON CONFLICT DO NOTHING;
